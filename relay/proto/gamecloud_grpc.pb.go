// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: proto/gamecloud.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	RelayService_AuthenticateUser_FullMethodName = "/gamecloud.RelayService/AuthenticateUser"
	RelayService_ValidateToken_FullMethodName    = "/gamecloud.RelayService/ValidateToken"
	RelayService_CreateRoom_FullMethodName       = "/gamecloud.RelayService/CreateRoom"
	RelayService_GetRoom_FullMethodName          = "/gamecloud.RelayService/GetRoom"
	RelayService_DeleteRoom_FullMethodName       = "/gamecloud.RelayService/DeleteRoom"
	RelayService_UpdateRoomState_FullMethodName  = "/gamecloud.RelayService/UpdateRoomState"
	RelayService_JoinRoom_FullMethodName         = "/gamecloud.RelayService/JoinRoom"
	RelayService_LeaveRoom_FullMethodName        = "/gamecloud.RelayService/LeaveRoom"
	RelayService_KickPlayer_FullMethodName       = "/gamecloud.RelayService/KickPlayer"
	RelayService_SendGameAction_FullMethodName   = "/gamecloud.RelayService/SendGameAction"
	RelayService_EndGame_FullMethodName          = "/gamecloud.RelayService/EndGame"
	RelayService_PersistGameState_FullMethodName = "/gamecloud.RelayService/PersistGameState"
)

// RelayServiceClient is the client API for RelayService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RelayServiceClient interface {
	AuthenticateUser(ctx context.Context, in *AuthenticateRequest, opts ...grpc.CallOption) (*AuthenticateResponse, error)
	ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
	CreateRoom(ctx context.Context, in *CreateRoomRequest, opts ...grpc.CallOption) (*Room, error)
	GetRoom(ctx context.Context, in *GetRoomRequest, opts ...grpc.CallOption) (*Room, error)
	DeleteRoom(ctx context.Context, in *DeleteRoomRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateRoomState(ctx context.Context, in *UpdateRoomStateRequest, opts ...grpc.CallOption) (*Room, error)
	JoinRoom(ctx context.Context, in *JoinRoomRequest, opts ...grpc.CallOption) (*JoinRoomResponse, error)
	LeaveRoom(ctx context.Context, in *LeaveRoomRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	KickPlayer(ctx context.Context, in *KickPlayerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SendGameAction(ctx context.Context, in *GameAction, opts ...grpc.CallOption) (*GameActionAck, error)
	EndGame(ctx context.Context, in *EndGameRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	PersistGameState(ctx context.Context, in *PersistGameStateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type relayServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRelayServiceClient(cc grpc.ClientConnInterface) RelayServiceClient {
	return &relayServiceClient{cc}
}

func (c *relayServiceClient) AuthenticateUser(ctx context.Context, in *AuthenticateRequest, opts ...grpc.CallOption) (*AuthenticateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AuthenticateResponse)
	err := c.cc.Invoke(ctx, RelayService_AuthenticateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayServiceClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTokenResponse)
	err := c.cc.Invoke(ctx, RelayService_ValidateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayServiceClient) CreateRoom(ctx context.Context, in *CreateRoomRequest, opts ...grpc.CallOption) (*Room, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Room)
	err := c.cc.Invoke(ctx, RelayService_CreateRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayServiceClient) GetRoom(ctx context.Context, in *GetRoomRequest, opts ...grpc.CallOption) (*Room, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Room)
	err := c.cc.Invoke(ctx, RelayService_GetRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayServiceClient) DeleteRoom(ctx context.Context, in *DeleteRoomRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayService_DeleteRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayServiceClient) UpdateRoomState(ctx context.Context, in *UpdateRoomStateRequest, opts ...grpc.CallOption) (*Room, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Room)
	err := c.cc.Invoke(ctx, RelayService_UpdateRoomState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayServiceClient) JoinRoom(ctx context.Context, in *JoinRoomRequest, opts ...grpc.CallOption) (*JoinRoomResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinRoomResponse)
	err := c.cc.Invoke(ctx, RelayService_JoinRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayServiceClient) LeaveRoom(ctx context.Context, in *LeaveRoomRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayService_LeaveRoom_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayServiceClient) KickPlayer(ctx context.Context, in *KickPlayerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayService_KickPlayer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayServiceClient) SendGameAction(ctx context.Context, in *GameAction, opts ...grpc.CallOption) (*GameActionAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GameActionAck)
	err := c.cc.Invoke(ctx, RelayService_SendGameAction_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayServiceClient) EndGame(ctx context.Context, in *EndGameRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayService_EndGame_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayServiceClient) PersistGameState(ctx context.Context, in *PersistGameStateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, RelayService_PersistGameState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RelayServiceServer is the server API for RelayService service.
// All implementations must embed UnimplementedRelayServiceServer
// for forward compatibility.
type RelayServiceServer interface {
	AuthenticateUser(context.Context, *AuthenticateRequest) (*AuthenticateResponse, error)
	ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
	CreateRoom(context.Context, *CreateRoomRequest) (*Room, error)
	GetRoom(context.Context, *GetRoomRequest) (*Room, error)
	DeleteRoom(context.Context, *DeleteRoomRequest) (*emptypb.Empty, error)
	UpdateRoomState(context.Context, *UpdateRoomStateRequest) (*Room, error)
	JoinRoom(context.Context, *JoinRoomRequest) (*JoinRoomResponse, error)
	LeaveRoom(context.Context, *LeaveRoomRequest) (*emptypb.Empty, error)
	KickPlayer(context.Context, *KickPlayerRequest) (*emptypb.Empty, error)
	SendGameAction(context.Context, *GameAction) (*GameActionAck, error)
	EndGame(context.Context, *EndGameRequest) (*emptypb.Empty, error)
	PersistGameState(context.Context, *PersistGameStateRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedRelayServiceServer()
}

// UnimplementedRelayServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRelayServiceServer struct{}

func (UnimplementedRelayServiceServer) AuthenticateUser(context.Context, *AuthenticateRequest) (*AuthenticateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthenticateUser not implemented")
}
func (UnimplementedRelayServiceServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateToken not implemented")
}
func (UnimplementedRelayServiceServer) CreateRoom(context.Context, *CreateRoomRequest) (*Room, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRoom not implemented")
}
func (UnimplementedRelayServiceServer) GetRoom(context.Context, *GetRoomRequest) (*Room, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoom not implemented")
}
func (UnimplementedRelayServiceServer) DeleteRoom(context.Context, *DeleteRoomRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoom not implemented")
}
func (UnimplementedRelayServiceServer) UpdateRoomState(context.Context, *UpdateRoomStateRequest) (*Room, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRoomState not implemented")
}
func (UnimplementedRelayServiceServer) JoinRoom(context.Context, *JoinRoomRequest) (*JoinRoomResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinRoom not implemented")
}
func (UnimplementedRelayServiceServer) LeaveRoom(context.Context, *LeaveRoomRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveRoom not implemented")
}
func (UnimplementedRelayServiceServer) KickPlayer(context.Context, *KickPlayerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KickPlayer not implemented")
}
func (UnimplementedRelayServiceServer) SendGameAction(context.Context, *GameAction) (*GameActionAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendGameAction not implemented")
}
func (UnimplementedRelayServiceServer) EndGame(context.Context, *EndGameRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndGame not implemented")
}
func (UnimplementedRelayServiceServer) PersistGameState(context.Context, *PersistGameStateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PersistGameState not implemented")
}
func (UnimplementedRelayServiceServer) mustEmbedUnimplementedRelayServiceServer() {}
func (UnimplementedRelayServiceServer) testEmbeddedByValue()                      {}

// UnsafeRelayServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RelayServiceServer will
// result in compilation errors.
type UnsafeRelayServiceServer interface {
	mustEmbedUnimplementedRelayServiceServer()
}

func RegisterRelayServiceServer(s grpc.ServiceRegistrar, srv RelayServiceServer) {
	// If the following call pancis, it indicates UnimplementedRelayServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RelayService_ServiceDesc, srv)
}

func _RelayService_AuthenticateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthenticateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).AuthenticateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_AuthenticateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).AuthenticateUser(ctx, req.(*AuthenticateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).ValidateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_ValidateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayService_CreateRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).CreateRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_CreateRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).CreateRoom(ctx, req.(*CreateRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayService_GetRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).GetRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_GetRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).GetRoom(ctx, req.(*GetRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayService_DeleteRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).DeleteRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_DeleteRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).DeleteRoom(ctx, req.(*DeleteRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayService_UpdateRoomState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoomStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).UpdateRoomState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_UpdateRoomState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).UpdateRoomState(ctx, req.(*UpdateRoomStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayService_JoinRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).JoinRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_JoinRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).JoinRoom(ctx, req.(*JoinRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayService_LeaveRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).LeaveRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_LeaveRoom_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).LeaveRoom(ctx, req.(*LeaveRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayService_KickPlayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KickPlayerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).KickPlayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_KickPlayer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).KickPlayer(ctx, req.(*KickPlayerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayService_SendGameAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameAction)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).SendGameAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_SendGameAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).SendGameAction(ctx, req.(*GameAction))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayService_EndGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndGameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).EndGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_EndGame_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).EndGame(ctx, req.(*EndGameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RelayService_PersistGameState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PersistGameStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayServiceServer).PersistGameState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RelayService_PersistGameState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayServiceServer).PersistGameState(ctx, req.(*PersistGameStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RelayService_ServiceDesc is the grpc.ServiceDesc for RelayService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RelayService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gamecloud.RelayService",
	HandlerType: (*RelayServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AuthenticateUser",
			Handler:    _RelayService_AuthenticateUser_Handler,
		},
		{
			MethodName: "ValidateToken",
			Handler:    _RelayService_ValidateToken_Handler,
		},
		{
			MethodName: "CreateRoom",
			Handler:    _RelayService_CreateRoom_Handler,
		},
		{
			MethodName: "GetRoom",
			Handler:    _RelayService_GetRoom_Handler,
		},
		{
			MethodName: "DeleteRoom",
			Handler:    _RelayService_DeleteRoom_Handler,
		},
		{
			MethodName: "UpdateRoomState",
			Handler:    _RelayService_UpdateRoomState_Handler,
		},
		{
			MethodName: "JoinRoom",
			Handler:    _RelayService_JoinRoom_Handler,
		},
		{
			MethodName: "LeaveRoom",
			Handler:    _RelayService_LeaveRoom_Handler,
		},
		{
			MethodName: "KickPlayer",
			Handler:    _RelayService_KickPlayer_Handler,
		},
		{
			MethodName: "SendGameAction",
			Handler:    _RelayService_SendGameAction_Handler,
		},
		{
			MethodName: "EndGame",
			Handler:    _RelayService_EndGame_Handler,
		},
		{
			MethodName: "PersistGameState",
			Handler:    _RelayService_PersistGameState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/gamecloud.proto",
}

const (
	GameEventService_OnPlayerJoined_FullMethodName      = "/gamecloud.GameEventService/OnPlayerJoined"
	GameEventService_OnPlayerLeft_FullMethodName        = "/gamecloud.GameEventService/OnPlayerLeft"
	GameEventService_OnRoomClosed_FullMethodName        = "/gamecloud.GameEventService/OnRoomClosed"
	GameEventService_OnGameCompleted_FullMethodName     = "/gamecloud.GameEventService/OnGameCompleted"
	GameEventService_OnGameStateChanged_FullMethodName  = "/gamecloud.GameEventService/OnGameStateChanged"
	GameEventService_OnMatchmakingResult_FullMethodName = "/gamecloud.GameEventService/OnMatchmakingResult"
)

// GameEventServiceClient is the client API for GameEventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GameEventServiceClient interface {
	OnPlayerJoined(ctx context.Context, in *PlayerEvent, opts ...grpc.CallOption) (*EventAck, error)
	OnPlayerLeft(ctx context.Context, in *PlayerEvent, opts ...grpc.CallOption) (*EventAck, error)
	OnRoomClosed(ctx context.Context, in *RoomEvent, opts ...grpc.CallOption) (*EventAck, error)
	OnGameCompleted(ctx context.Context, in *GameCompletedEvent, opts ...grpc.CallOption) (*EventAck, error)
	OnGameStateChanged(ctx context.Context, in *GameStateEvent, opts ...grpc.CallOption) (*EventAck, error)
	OnMatchmakingResult(ctx context.Context, in *MatchmakingResultEvent, opts ...grpc.CallOption) (*EventAck, error)
}

type gameEventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGameEventServiceClient(cc grpc.ClientConnInterface) GameEventServiceClient {
	return &gameEventServiceClient{cc}
}

func (c *gameEventServiceClient) OnPlayerJoined(ctx context.Context, in *PlayerEvent, opts ...grpc.CallOption) (*EventAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventAck)
	err := c.cc.Invoke(ctx, GameEventService_OnPlayerJoined_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameEventServiceClient) OnPlayerLeft(ctx context.Context, in *PlayerEvent, opts ...grpc.CallOption) (*EventAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventAck)
	err := c.cc.Invoke(ctx, GameEventService_OnPlayerLeft_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameEventServiceClient) OnRoomClosed(ctx context.Context, in *RoomEvent, opts ...grpc.CallOption) (*EventAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventAck)
	err := c.cc.Invoke(ctx, GameEventService_OnRoomClosed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameEventServiceClient) OnGameCompleted(ctx context.Context, in *GameCompletedEvent, opts ...grpc.CallOption) (*EventAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventAck)
	err := c.cc.Invoke(ctx, GameEventService_OnGameCompleted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameEventServiceClient) OnGameStateChanged(ctx context.Context, in *GameStateEvent, opts ...grpc.CallOption) (*EventAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventAck)
	err := c.cc.Invoke(ctx, GameEventService_OnGameStateChanged_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameEventServiceClient) OnMatchmakingResult(ctx context.Context, in *MatchmakingResultEvent, opts ...grpc.CallOption) (*EventAck, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EventAck)
	err := c.cc.Invoke(ctx, GameEventService_OnMatchmakingResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GameEventServiceServer is the server API for GameEventService service.
// All implementations must embed UnimplementedGameEventServiceServer
// for forward compatibility.
type GameEventServiceServer interface {
	OnPlayerJoined(context.Context, *PlayerEvent) (*EventAck, error)
	OnPlayerLeft(context.Context, *PlayerEvent) (*EventAck, error)
	OnRoomClosed(context.Context, *RoomEvent) (*EventAck, error)
	OnGameCompleted(context.Context, *GameCompletedEvent) (*EventAck, error)
	OnGameStateChanged(context.Context, *GameStateEvent) (*EventAck, error)
	OnMatchmakingResult(context.Context, *MatchmakingResultEvent) (*EventAck, error)
	mustEmbedUnimplementedGameEventServiceServer()
}

// UnimplementedGameEventServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGameEventServiceServer struct{}

func (UnimplementedGameEventServiceServer) OnPlayerJoined(context.Context, *PlayerEvent) (*EventAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPlayerJoined not implemented")
}
func (UnimplementedGameEventServiceServer) OnPlayerLeft(context.Context, *PlayerEvent) (*EventAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnPlayerLeft not implemented")
}
func (UnimplementedGameEventServiceServer) OnRoomClosed(context.Context, *RoomEvent) (*EventAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnRoomClosed not implemented")
}
func (UnimplementedGameEventServiceServer) OnGameCompleted(context.Context, *GameCompletedEvent) (*EventAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnGameCompleted not implemented")
}
func (UnimplementedGameEventServiceServer) OnGameStateChanged(context.Context, *GameStateEvent) (*EventAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnGameStateChanged not implemented")
}
func (UnimplementedGameEventServiceServer) OnMatchmakingResult(context.Context, *MatchmakingResultEvent) (*EventAck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMatchmakingResult not implemented")
}
func (UnimplementedGameEventServiceServer) mustEmbedUnimplementedGameEventServiceServer() {}
func (UnimplementedGameEventServiceServer) testEmbeddedByValue()                          {}

// UnsafeGameEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GameEventServiceServer will
// result in compilation errors.
type UnsafeGameEventServiceServer interface {
	mustEmbedUnimplementedGameEventServiceServer()
}

func RegisterGameEventServiceServer(s grpc.ServiceRegistrar, srv GameEventServiceServer) {
	// If the following call pancis, it indicates UnimplementedGameEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GameEventService_ServiceDesc, srv)
}

func _GameEventService_OnPlayerJoined_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameEventServiceServer).OnPlayerJoined(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GameEventService_OnPlayerJoined_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameEventServiceServer).OnPlayerJoined(ctx, req.(*PlayerEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameEventService_OnPlayerLeft_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PlayerEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameEventServiceServer).OnPlayerLeft(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GameEventService_OnPlayerLeft_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameEventServiceServer).OnPlayerLeft(ctx, req.(*PlayerEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameEventService_OnRoomClosed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoomEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameEventServiceServer).OnRoomClosed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GameEventService_OnRoomClosed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameEventServiceServer).OnRoomClosed(ctx, req.(*RoomEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameEventService_OnGameCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameCompletedEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameEventServiceServer).OnGameCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GameEventService_OnGameCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameEventServiceServer).OnGameCompleted(ctx, req.(*GameCompletedEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameEventService_OnGameStateChanged_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameStateEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameEventServiceServer).OnGameStateChanged(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GameEventService_OnGameStateChanged_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameEventServiceServer).OnGameStateChanged(ctx, req.(*GameStateEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _GameEventService_OnMatchmakingResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchmakingResultEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameEventServiceServer).OnMatchmakingResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GameEventService_OnMatchmakingResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameEventServiceServer).OnMatchmakingResult(ctx, req.(*MatchmakingResultEvent))
	}
	return interceptor(ctx, in, info, handler)
}

// GameEventService_ServiceDesc is the grpc.ServiceDesc for GameEventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GameEventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gamecloud.GameEventService",
	HandlerType: (*GameEventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnPlayerJoined",
			Handler:    _GameEventService_OnPlayerJoined_Handler,
		},
		{
			MethodName: "OnPlayerLeft",
			Handler:    _GameEventService_OnPlayerLeft_Handler,
		},
		{
			MethodName: "OnRoomClosed",
			Handler:    _GameEventService_OnRoomClosed_Handler,
		},
		{
			MethodName: "OnGameCompleted",
			Handler:    _GameEventService_OnGameCompleted_Handler,
		},
		{
			MethodName: "OnGameStateChanged",
			Handler:    _GameEventService_OnGameStateChanged_Handler,
		},
		{
			MethodName: "OnMatchmakingResult",
			Handler:    _GameEventService_OnMatchmakingResult_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/gamecloud.proto",
}
